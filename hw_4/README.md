# Weaviate - Vector Database
![weaviate_logo](/hw_4/pictures/weaviate_logo.png)

## История развития Weaviate
[Weaviate - это опенсорсная СУБД](https://weaviate.io/), предназначенная для хранения, поиска и анализа как структурированных, так и неструктурированных данных. История развития этой системы начинается в _2018_ году, когда команда разработчиков из компании SeMI Technologies начала работу над проектом.

Идея создания Weaviate возникла из необходимости разработки системы, способной эффективно обрабатывать сложные структурированные и неструктурированные данные в реальном времени. Разработчики стремились создать интеллектуальную СУБД, способную обрабатывать данные различных типов и источников, а также предоставлять разнообразные методы поиска и анализа информации. Основными достоинствами Weaviate являются семантический поиск и семантическая классификация данных.

Первая версия Weaviate была выпущена в конце _2018_ года и содержала основные функции, такие как хранение структурированных и неструктурированных данных, поиск информации с использованием векторных запросов и автоматическое индексирование данных для быстрого доступа. С течением времени разработчики постоянно совершенствовали систему. В _2020_ году была запущена облачная версия Weaviate, что позволило пользователям использовать систему без необходимости установки и настройки на собственных серверах.

В настоящее время Weaviate является одной из ведущих СУБД, предоставляя широкий спектр возможностей для хранения и анализа данных различных типов. Разработчики продолжают активно развивать систему, добавляя новые функции и интеграции, чтобы удовлетворить потребности пользователей в области обработки больших данных и машинного обучения.

## Инструменты для взаимодействия с Weaviate
Weaviate предлагает [следующие способы взаимодействия](https://weaviate.io/developers/weaviate/concepts/interface):
1. [GraphQL API](https://weaviate.io/developers/weaviate/api/graphql) -- имеет достаточно жестко фиксированный формат с целью борьбы с переизбытком/недостатком возвращенных данных, обычно используется для доступа к объектам данных, будь это простой просмотр объекта или полноценный скалярный/векторный поиск.
2. [REST API](https://weaviate.io/developers/weaviate/api/rest) -- как правило, используется для CRUD-операций и управления самой базой данных. С версии v1.23 доступен стабильный [gRPC API](https://weaviate.io/developers/weaviate/api/grpc), который быстрее и проще в использовании.
3. Клиентские библиотеки для некоторых популярных языков (использующие вышеупомянутые принципы):
    - [Python](https://weaviate.io/developers/weaviate/client-libraries/python)
    - [JavaScript/TypeScript](https://weaviate.io/developers/weaviate/client-libraries/typescript)
    - [Go](https://weaviate.io/developers/weaviate/client-libraries/go)
    - [Java](https://weaviate.io/developers/weaviate/client-libraries/java)
Также присутствует [небольшой список библиотек, поддерживаемых сообществом](https://weaviate.io/developers/weaviate/client-libraries/community)(.NET/C#, PHP, Ruby).
4. Возможно и взаимодействие из командной строки, так как есть [официальный CLI](https://github.com/weaviate/weaviate-cli), с помощью него можно взаимодействовать с Weaviate из терминала.

## Какой database engine используется в Weaviate?
Weaviate использует свой собственный database engine, отличный от привычных нам в других СУБД, и сам по сути является таковым. Вместо традиционного формата хранения данных используется механизм "векторной индексации" (vector indexing). Пространство данных представляется не привычными строками и колонками, а чем-то похожим на векторное пространство, где объекты со схожими параметрами будут находиться, условно говоря, недалеко друг от друга. Поиск, как правило, не выдаст 100% корректный результат, но найдет весьма похожий. Подробнее по [ссылке](https://weaviate.io/developers/weaviate/introduction), раздел "What is a vector database?".

## Как устроен язык запросов в Weaviate?
В основном запросы осуществляются с помощью функций из библиотек для языков программирования. Есть стандартные CRUD-операции: `create` (создать коллекцию), `insert`, `insert_many`, `delete_by_id`, `delete_many`, `update`... Есть и привычные `exists`, `replace`, простой поиск `fetch_objects` наподобие `SELECT` в SQL, но интереснее посмотреть основную фишку Weaviate - векторный поиск.

Пользуясь облачной версией Weaviate, создадим там схему-песочницу:
![creating_sandbox](/hw_4/pictures/creating_sandbox.png)

Соединимся с песочницей по URL и токену, создадим там таблицу `Question` и заполним ее данными из небольшого датасета:

```
client = weaviate.connect_to_wcs(
    cluster_url="https://mipt-sbt-db-5bhod7yu.weaviate.network",
    auth_credentials=weaviate.auth.AuthApiKey("your weaviate authorization token here"),
    headers={
        "X-OpenAI-Api-Key": "your openai token here"
    }
)

try:
    # creating collection "Question"
    questions = client.collections.create(
        name="Question",
        vectorizer_config=wvc.config.Configure.Vectorizer.text2vec_openai(),
        generative_config=wvc.config.Configure.Generative.openai()
    )

    # importing data
    resp = requests.get('https://raw.githubusercontent.com/weaviate-tutorials/quickstart/main/data/jeopardy_tiny.json')
    data = json.loads(resp.text)  # loading data

    question_objs = list()
    for i, d in enumerate(data):
        question_objs.append({
            "answer": d["Answer"],
            "question": d["Question"],
            "category": d["Category"],
        })

    questions = client.collections.get("Question")
    questions.data.insert_many(question_objs)


finally:
    client.close()  # closing client
```

Поскольку в коллекции сконфигурирован `Vectorizer`, наши данные хранятся там не просто в виде строки, а в виде вектора.
Значит, теперь мы можем применить семантический векторный поиск! Поиск `near_text` ищет те объекты, чьи вектора наиболее сходны с запрашиваемым:

```
# semantic search for vector which are most similar to that of "biology"
questions = client.collections.get("Question")
response = questions.query.near_text(
    query="biology",
    limit=2
)
print(response.objects[0].properties) # getting only first object
```

Результат:
![ans1](/hw_4/pictures/ans1.png)

Возвращено 2 результата, поскольку установлен лимит в 2 ответа.

Этот же поиск можно отфильтровать. Например, хотим видеть ответы на предыдущий запрос только из категории "ANIMALS" (животные). Тогда отфильтруем:
```
response = questions.query.near_text(
    query="biology",
    limit=2,
    filters=wvc.query.Filter.by_property("category").equal("ANIMALS")
)
print(response.objects[0].properties)
```

Результат:
![ans2](/hw_4/pictures/ans2.png)

Теперь попробуем генеративный поиск: в нем промптом для LLM (большой языковой модели) служит комбинация запроса пользователя и полученной из базы данных информации.
Попросим найденные результаты объяснить ОЧЕНЬ подробно:

```
response = questions.generate.near_text(
    query="biology",
    limit=2,
    single_prompt="Explain {answer} as you might to a five-year-old."
)
print(response.objects[0].generated)
```

Увидим результат:
![ans3](/hw_4/pictures/ans3.png)

Можно видеть, что результаты те же самые, что и раньше, но теперь они включают в себя дополнительно сгенерированный текст с объяснением каждого ответа.

Теперь посмотрим групповой генеративный поиск, в которым один ответ использует все результаты запроса к базе данных:
```
response = questions.generate.near_text(
    query="Cute animals",
    limit=3,
    grouped_task="What do these animals have in common, if anything?"
)
print(response.generated)
```

Результат:
![ans4](/hw_4/pictures/ans4.png)

## Распределение файлов БД по разным носителям?
Weaviate может автоматически реплицировать данные по узлам в кластере с несколькими узлами. Поскольку кластер предполагает,
что присутствует устойчивость к разделению(P в CAP-теореме), то остаются консистентность(C) и доступность(A). Weaviate по
умолчанию склоняется к доступности для обработки больших объемов записей с минимальной задержкой. Тем не менее, есть
[механизм гибкой балансировки между доступностью и консистентностью, причем для последней как для чтения, так и для записи](https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency) (основан на механизме подтверждений от узлов с некоторой толератностью к числу соответствующих узлов).
Подробнее про балансировку [здесь](https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency).

Репликация в Weaviate вдохновлена такими СУБД, как Apache Cassandra. Используется бесклассовый дизайн, означающий, что
не существует первичных и вторичных узлов. Между пользователем и кластером присутствует балансировщик нагрузки, то есть
пользователь не обращается напрямую к определенному узлу. Количество узлов для подтверждения чтения/записи может варьироваться:
при выбранном параметре `ALL` база данных синхронизируется, иначе (возможно с версии v1.18) с точки зрения пользователя
запись асинхронна. Подробнее [здесь](https://weaviate.io/developers/weaviate/concepts/replication-architecture).

## На каком языке/языках программирования написана Weaviate?
Weaviate фактически полностью написана на `Go`. Скриншот с гитхаба:
![weaviate_languages](/hw_4/pictures/weaviate_languages.png)

## Какие типы индексов поддерживаются в Weaviate? Приведите пример создания индексов.
Weaviate поддерживает два типа индексов:
1. Approximate nearest neigbour index(ANN) - используется для обслуживания всех запросов, связанных с векторным поиском.
2. Inverted index - позволяет осуществлять фильтрацию по свойствам и выполнять [BM25 запросы](https://ru.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20%E2%80%94%20%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BD%D0%B5%D1%83%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D1%87%D0%B5%D0%BD%D0%BD%D0%BE%D0%BC,%D0%BD%D0%B8%D0%BC%D0%B8%20(%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%2C%20%D0%B1%D0%BB%D0%B8%D0%B7%D0%BE%D1%81%D1%82%D0%B8).).

Среди ANN-индексов Weaviate поддерживает:
- `HNSW index` - позволяет существенно увеличить скорость векторного поиска с небольшим уменьшением его точности.
Как правило, запросы к большим датасетам начинают работать за логарифмическое время. Во время построения индекса
алгоритм HNSW создает несколько слоев, а во время запросов использует их, чтобы быстро и эффективно построить
примерный список ближайших соседей. Картинка:
![hnsw_layers](/hw_4/pictures/hnsw_layers.png)

Начиная с верхних слоев, где меньше всего точек, HNSW слой за слоем спускается вниз, ко всему графу, и каждый раз
перестраивает список ближайших соседей, отсеивая таким образом множество данных, которые не имеет смысл проверять.
Кроме того, хранятся лишь списки для верхних слоев, что эффективно по памяти.

Синтаксис создания HNSW индекса на `GraphQL`:
```
{
    "classes": [
        {
            "class": "Question",
            "properties": [],
            "vectorIndexType": "hnsw"
            "vectorIndexConfig": {
                "efConstruction": 128,
                "ef": -1,
                "dynamicEfMin": 100,
                "dynamicEfMax": 500,
                "dynamicEfFactor": 8
            }
        },
    ]
}
```

На `Python`:
```
configuration = {
    "class": "Question",
    "efConstruction": 128,
    "ef": -1,
    "dynamicEfMin": 100,
    "dynamicEfMax": 500,
    "dynamicEfFactor": 8
}

index = client.create_index("myIndex", configuration)
```

Параметр `ef` отвечает за балансировку скорости и точности, являясь показателем размер динамического списка,
используемого HNSW алгоритмом. Чем он больше, тем шире область поиска, что увеличивает точность, но потенциально
замедляет запрос. Значение -1 устанавливает динамический размер списка. `dynamicEfMin` - нижняя граница длины списка,
`dynamicEfMax` - верхняя, `dynamicEfFactor` - диапазон длины списка.

- `flat index` - легковесный индекс, введенный сравнительно недавно (v1.23), который быстро строится и занимает
очень небольшое место в памяти. Хорош в случаях, когда каждый пользователь обладает своим изолированным
небольшим датасетом. В отличие от HNSW, фактически представляет собой один слой объектов. Недостаток очевиден:
плохо работает с большими датасетами, поскольку работает за линейное от количества объектов время, безнадежно
проигрывая HNSW.

Среди inverted индексов Weaviate поддерживает:
- `filterable index` - используется для построения быстрых [Roaring Bitmaps](https://www.baeldung.com/java-roaring-bitmap-intro)
индексов для быстрого перехода по большим блокам памяти;
- `searchable index` - для BM25 или гибридного поисков.

Задаются в "properties" схемы как "indexFilterable" и "indexSearchable" соответственно:
```
{
    "class": "Question",
    "properties": [
        {
            "indexFilterable": true,
            "indexSearchable": true,
            "dataType": [
                "text"
            ],
            "name": "name"
        }
    ]
}
```

`Filterable index` может быть применен только при фильтрации запроса, в то время как `searchable index` может применяться
и при поиске, и при фильтрации (не так быстр, как `filterable index`, но меньше использует диск и позволяет осуществлять
вставку быстрее).

Подробнее об индексации в Weaviate по [ссылке](https://weaviate.io/developers/weaviate/concepts/indexing).

## Как строится процесс выполнения запросов в СУБД Weaviate?
## Есть ли для вашей СУБД понятие "план запроса"
Процесс выполнения запросов в СУБД Weaviate начинается с того, что клиентское приложение формирует и отправляет запрос на сервер Weaviate. Затем сервер Weaviate получает запрос и выполняет следующие шаги для его обработки:

1. _Анализ запроса_: Weaviate анализирует поступивший запрос, определяет его тип, и проверяет его синтаксис и корректность;

2. _Планирование запроса_: В зависимости от типа запроса и структуры данных Weaviate планирует процесс выполнения запроса, определяет, какие данные и какие индексы нужно использовать для его выполнения;

3. _Получение данных_: Weaviate извлекает необходимые данные из хранилища, эффективно используя индексы для поиска и фильтрации данных;

4. _Обработка запроса_: После получения данных, Weaviate обрабатывает запрос, выполняя операции поиска, фильтрации, агрегации или аналитики в соответствии с запросом;

5. _Возврат результата_: По завершении обработки Weaviate возвращает результаты запроса клиентскому приложению.

Процесс выполнения запросов в Weaviate характеризуется эффективным использованием индексов для ускорения поиска и агрегации данных, а также гибкостью в обработке различных типов запросов, включая текстовый поиск, гео-запросы и работу с многомерными векторами данных. Это позволяет обеспечить эффективное выполнение запросов и высокую производительность при работе с данными различных типов и объемов.

Подробнее о разных типах, например, векторного поиска [здесь](https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/inside_queries_1).

## Поддерживаются ли транзакции в Weaviate? Если да, то расскажите о них. Если нет, то существует ли альтернатива?
Weaviate не поддерживает транзакции. В самой [философии](https://weaviate.io/developers/weaviate/concepts/replication-architecture/philosophy)
СУБД указано, что в случаях, когда Weaviate используется как первостепенная СУБД, данные обычно нетранзакционные.
На это намекает и уклон по умолчанию к доступности вместо консистентности в CAP-теореме.
Тем не менее, присутствуют такие механизмы обеспечения целостности данных, как версионирование, аудит и техники отмены изменений.
Например, можно отслеживать историю изменений объектов, а также проводить поиск и фильтрацию данных в соответствии с их версиями.

## Какие методы восстановления поддерживаются в Weaviate? Расскажите о них.
Из методов восстановления в Weaviate можно выделить следующие:
1. _Резервное копирование_: Weaviate поддерживает создание резервных копий данных, что позволяет восстанавливать
базу данных после сбоев или потери данных. Реализация резервного копирования отлично интегрирована с популярными
облачными хранилищами наподобие [AWS S3](https://aws.amazon.com/ru/s3/), [GCS](https://cloud.google.com/storage),
[Azure](https://azure.microsoft.com/en-us), оно может проводиться с разными хранилищами, возможно и полное,
и частичное восстановление;

2. _Точка сохранения_: Weaviate может использовать механизмы точек сохранения для сохранения состояния базы данных на определенный момент времени. Это позволяет восстановить базу данных к конкретному состоянию в случае необходимости;

3. _Репликация данных_: Weaviate позволяет создавать реплики данных для обеспечения их доступности и возможности восстановления в случае сбоев. Репликация данных обеспечивает защиту от потери информации и повышает отказоустойчивость;

4. _Версионирование данных_: Weaviate предоставляет возможность отслеживать и восстанавливать предыдущие версии данных. Это позволяет восстанавливать ранее измененную или удаленную информацию;

5. _Автоматическое восстановление_: Некоторые сбои и неполадки в Weaviate могут быть автоматически восстановлены благодаря встроенным механизмам обнаружения и исправления ошибок;

6. _Аудит и журналирование_: Weaviate поддерживает аудит действий с данными и журналирование, что позволяет отслеживать изменения и восстанавливать утерянные или поврежденные данные.

## Расскажите про шардинг в Weaviate. Какие типы используются? Принцип работы.
Шардинг в Weaviate напрямую связан с горизонтальным масштабированием. При шардинге данные распределяются по нескольким узлам
для обеспечения баланса нагрузки и повышения производительности.

Принцип работы шардинга в Weaviate:
- При добавлении новых данных или обновлении существующих Weaviate сперва определяет, к какому шарду относится информация.
- Далее данные могут быть распределены между узлами, в некоторых случаях возможно решардирование (перераспределение шардов между узлами).
- При запросе информации Weaviate определяет, в каком шарде может находиться нужная информация, и затем делает запрос на соответствующий узел.
- Затем результаты запросов собираются и предоставляются клиентскому приложению.

Разнесение данных по шардам осуществляется с помощью ключа шардинга. С версии v1.8.0 ключом шардинга всегда
является UUID объекта, а на текущий момент алгоритм шардинга - 64-битный `Murmur-3` хеш. В Weaviate присутствует
механизм решардинга. Для ускорения процесса при шардировании используется так называемая система виртуального шардинга.
Тем не менее, в особенности из-за `HNSW-индекса`, механизм дорогой и не должен использоваться часто, а условная
"стоимость" решардинга сравнима с таковой у вставки данных (учитывая, очевидно, только те, которые перемещаются
при решардинге). При распределении шардов Weaviate, как правило, старается помещать их сначала на те узлы,
на которых больше всего свободного дискового пространства.

[В документации Weaviate](https://weaviate.io/developers/weaviate/concepts/cluster) шардинг советуют использовать в основном
для того, чтобы иметь возможность работать с большими датасетами. 

Плюсы шардинга:
- Возможность использовать большие датасеты;
- Ускорение вставки данных.

Минусы шардинга:
- Пропускная способность не увеличивается при увеличении количества шардов.

Подробнее о шардинге в Weaviate можно прочесть [здесь](https://weaviate.io/developers/weaviate/concepts/cluster).

## Возможно ли применить термины Data Mining, Data Warehousing и OLAP к Weaviate?
Не удалось найти ничего, связанного с этими терминами, в документации к Weaviate :( Тем не менее, вот некоторые идеи:

- `Data Mining` относится к процессу извлечения интересных и ранее неизвестных паттернов из больших объемов данных, что можно сделать с помощью Weaviate, используя ее
первоначальный замысел как графовой СУБД и тесное взаимодействие с моделями искусственного интеллекта.

- `Data Warehousing` связан с процессом сбора, хранения и управления данными из различных источников, что также может быть реализовано с помощью Weaviate, так как
есть возможность объединять данные из разных источников.

- `OLAP` относится к технологии аналитической обработки данных, которая позволяет анализировать данные для принятия бизнес-решений. Благодаря своему выдающемуся
векторному поиску Weaviate потенциально может обеспечить возможность быстрого и глубокого анализа данных.
